!(function (e, t) { typeof exports === 'object' && typeof module !== 'undefined' ? t(exports, require('react'), require('react-native'), require('prop-types'), require('react-native/Libraries/Utilities/MatrixMath')) : typeof define === 'function' && define.amd ? define(['exports', 'react', 'react-native', 'prop-types', 'react-native/Libraries/Utilities/MatrixMath'], t) : t((e = e || self)['flip-timer'] = {}, e.React, e.reactNative, e.PropTypes, e.MatrixMath); }(this, (e, t, r, n, i) => {
  function a(e, t, r) {
    return t in e ? Object.defineProperty(e, t, {
      value: r, enumerable: !0, configurable: !0, writable: !0,
    }) : e[t] = r, e;
  } function o() { return (o = Object.assign || function (e) { for (let t = 1; t < arguments.length; t++) { const r = arguments[t]; for (const n in r)Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]); } return e; }).apply(this, arguments); } function s(e, t) { e.prototype = Object.create(t.prototype), e.prototype.constructor = e, e.__proto__ = t; } function u(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }t = t && t.hasOwnProperty('default') ? t.default : t, n = n && n.hasOwnProperty('default') ? n.default : n, i = i && i.hasOwnProperty('default') ? i.default : i; const l = r.StyleSheet.create({
    wrapper: { flexDirection: 'row' },
    numberWrapper: {
      backgroundColor: '#333333', margin: 3, shadowColor: '#1f1f1f', shadowOffset: { width: 0, height: 2 }, shadowRadius: 2, shadowOpacity: 1, elevation: 5,
    },
    card: {
      flex: 0.5, alignItems: 'center', justifyContent: 'center', borderColor: '#1f1f1f', overflow: 'hidden',
    },
    overflowContainer: { overflow: 'hidden' },
    number: { fontWeight: '700', color: '#cccccc' },
    flipCard: {
      position: 'absolute', left: 0, height: '50%', width: '100%', backgroundColor: '#333333', borderColor: '#1f1f1f', backfaceVisibility: 'hidden', alignItems: 'center', justifyContent: 'center',
    },
    separator: {
      marginHorizontal: 5, marginVertical: 10, alignItems: 'center', justifyContent: 'space-around',
    },
    circle: {
      height: 5, width: 5, borderRadius: 5, backgroundColor: '#333333',
    },
  }); const p = i.createIdentityMatrix; const c = i.multiplyInto; function m(e, t, r) { return e < 10 && (e = `0${e}`), t < 10 && (t = `0${t}`), r < 10 && (r = `0${r}`), { hours: e, minutes: t, seconds: r }; } const f = {
    createIdentityMatrix: p, multiplyInto: c, rotateXMatrix(e, t) { const r = Math.PI / 180 * t; const n = Math.cos(r); const i = Math.sin(r); c(e, e, [1, 0, 0, 0, 0, n, -i, 0, 0, i, n, 0, 0, 0, 0, 1]); }, perspectiveMatrix(e, t) { const r = p(); i.reusePerspectiveCommand(r, t), c(e, e, r); }, translateMatrix(e, t) { const r = t.x; const n = t.y; const a = t.z; const o = p(); i.reuseTranslate3dCommand(o, r, n, a), c(e, o, e); }, untranslateMatrix(e, t) { const r = t.x; const n = t.y; const a = t.z; const o = p(); i.reuseTranslate3dCommand(o, -r, -n, -a), c(e, e, o); }, formatNumberToTime(e) { const t = parseInt(e); const r = Math.floor(t / 3600); const n = Math.floor((t - 3600 * r) / 60); return m(r, n, t - 3600 * r - 60 * n); }, addTime(e, t, r) { if (e = parseInt(e), t = parseInt(t), r = parseInt(r), (r += 1) >= 60) { const n = r / 60 << 0; t += n, r -= 60 * n; } if (t >= 60) { const i = t / 60 << 0; e += i, t -= 60 * i; } return m(e, t, r); },
  }; function d(e) {
    const n = e.setRef; const i = e.type; const a = e.size; const o = e.number; const s = e.flipCardStyle; const u = e.numberStyle; return t.createElement(r.Animated.View, {
      ref: n,
      style: [l.flipCard, i === 'front' ? {
        top: 0, borderTopLeftRadius: a / 10, borderTopRightRadius: a / 10, borderBottomWidth: 0.5,
      } : {
        top: '50%', borderBottomLeftRadius: a / 10, borderBottomRightRadius: a / 10, borderTopWidth: 0.5,
      }, s],
    }, t.createElement(r.View, { style: l.overflowContainer }, t.createElement(r.Text, { style: [l.number, { transform: [i === 'front' ? { translateY: 0.3 * a } : { translateY: 0.3 * -a }], fontSize: a / 1.5, lineHeight: a / 1.5 }, u] }, o)));
  } function b(e) { const n = e.type; const i = e.size; const a = e.number; const o = e.cardStyle; const s = e.numberStyle; return t.createElement(r.View, { style: [l.card, n === 'upper' ? { borderBottomWidth: 0.5 } : { borderTopWidth: 0.5 }, o] }, t.createElement(r.Text, { style: [l.number, { transform: [n === 'upper' ? { translateY: 0.3 * i } : { translateY: 0.3 * -i }], fontSize: i / 1.5, lineHeight: i / 1.5 }, s] }, a)); }d.defaultProps = { flipCardStyle: {}, numberStyle: {} }, d.propTypes = {
    setRef: n.func.isRequired, type: n.string.isRequired, size: n.number.isRequired, number: n.oneOfType([n.string, n.number]).isRequired, flipCardStyle: n.object, numberStyle: n.object,
  }, b.defaultProps = { cardStyle: {}, numberStyle: {} }, b.propTypes = {
    type: n.string.isRequired, size: n.number.isRequired, number: n.oneOfType([n.string, n.number]).isRequired, cardStyle: n.object, numberStyle: n.object,
  }; const y = r.Dimensions.get('window').width; const h = (function (e) {
    function n(t) { let n; return a(u(n = e.call(this, t) || this), 'setFrontRef', (e) => { n.frontRef = e; }), a(u(n), 'setBackRef', (e) => { n.backRef = e; }), a(u(n), 'animateTick', () => { n.rotateFront.setValue(0), n.rotateBack.setValue(-180), r.Animated.parallel([r.Animated.timing(n.rotateFront, { toValue: 180, duration: 800, useNativeDriver: !0 }), r.Animated.timing(n.rotateBack, { toValue: 0, duration: 800, useNativeDriver: !0 })]).start(); }), a(u(n), 'transformRef', (e, t, r) => { const i = n.props.perspective; const a = f.createIdentityMatrix(); f.translateMatrix(a, { x: 0, y: r, z: 0 }), f.perspectiveMatrix(a, i), f.rotateXMatrix(a, t), f.untranslateMatrix(a, { x: 0, y: r, z: 0 }), e && e.setNativeProps({ style: { transform: [{ matrix: a }] } }); }), n.rotateFront = new r.Animated.Value(0), n.rotateBack = new r.Animated.Value(-180), n.frontRef = null, n.backRef = null, n; }s(n, e); const i = n.prototype; return i.componentDidMount = function () { const e = this; const t = this.props.size; this.animateTick(), this.rotateFront.addListener((r) => { const n = r.value; e.transformRef(e.frontRef, n, 0.3 * t); }), this.rotateBack.addListener((r) => { const n = r.value; e.transformRef(e.backRef, n, 0.3 * -t); }); }, i.shouldComponentUpdate = function (e) { const t = this.props.number; return e.number !== t && this.animateTick(), !0; }, i.render = function () {
      const e = this.props; const n = e.number; const i = e.previousNumber; const a = e.size; const o = e.numberWrapperStyle; const s = e.cardStyle; const u = e.flipCardStyle; const p = e.numberStyle; return t.createElement(r.View, { style: [l.numberWrapper, { width: 0.8 * a, height: 1.2 * a, borderRadius: a / 10 }, o] }, t.createElement(b, {
        type: 'upper', size: a, number: n, cardStyle: s, numberStyle: p,
      }), t.createElement(b, {
        type: 'lower', size: a, number: i, cardStyle: s, numberStyle: p,
      }), t.createElement(d, {
        setRef: this.setFrontRef, type: 'front', size: a, number: i, flipCardStyle: u, numberStyle: p,
      }), t.createElement(d, {
        setRef: this.setBackRef, type: 'back', size: a, number: n, flipCardStyle: u, numberStyle: p,
      }));
    }, n;
  }(t.Component)); function v(e) {
    let n = e.number; const i = e.unit; const a = e.size; const o = e.perspective; const s = e.numberWrapperStyle; const u = e.cardStyle; const p = e.flipCardStyle; const c = e.numberStyle; let m = (n = parseInt(n)) - 1; m = (m = i !== 'hours' ? m === -1 ? 59 : m : m === -1 ? 23 : m) < 10 ? `0${m}` : m; const f = (n = n < 10 ? `0${n}` : n).toString().split(''); const d = m.toString().split(''); return t.createElement(r.View, { style: l.wrapper }, t.createElement(h, {
      number: f[0], previousNumber: d[0], size: a, perspective: o, numberWrapperStyle: s, cardStyle: u, flipCardStyle: p, numberStyle: c,
    }), t.createElement(h, {
      number: f[1], previousNumber: d[1], size: a, perspective: o, numberWrapperStyle: s, cardStyle: u, flipCardStyle: p, numberStyle: c,
    }));
  } function S() { return t.createElement(r.View, { style: l.separator }, t.createElement(r.View, { style: l.circle }), t.createElement(r.View, { style: l.circle })); }h.defaultProps = { size: y / 6, perspective: 250 }, h.propTypes = {
    number: n.oneOfType([n.string, n.number]).isRequired, previousNumber: n.oneOfType([n.string, n.number]), perspective: n.number, size: n.number, numberWrapperStyle: n.object, cardStyle: n.object, flipCardStyle: n.object, numberStyle: n.object,
  }, v.defaultProps = { unit: 'seconds' }, v.propTypes = {
    number: n.oneOfType([n.string, n.number]).isRequired, unit: n.oneOf(['hours', 'minutes', 'seconds']), size: n.number, perspective: n.number, numberWrapperStyle: n.object, cardStyle: n.object, flipCardStyle: n.object, numberStyle: n.object,
  }; const w = (function (e) { function n() { for (var t, r = arguments.length, n = new Array(r), i = 0; i < r; i++)n[i] = arguments[i]; return a(u(t = e.call.apply(e, [this].concat(n)) || this), 'state', { hours: 0, minutes: 0, seconds: 0 }), a(u(t), 'updateTime', () => { const e = t.state; const r = e.hours; const n = e.minutes; const i = e.seconds; const a = f.addTime(r, n, i); t.setState(e => o({}, e, a)); }), t; }s(n, e); const i = n.prototype; return i.componentDidMount = function () { const e = this; const t = this.props; const r = t.time; const n = t.play; const i = f.formatNumberToTime(r); const a = i.hours; const o = i.minutes; const s = i.seconds; this.setState({ hours: a, minutes: o, seconds: s }, () => { n && (e.timer = setInterval(() => e.updateTime(), 1e3)); }); }, i.shouldComponentUpdate = function (e) { const t = this; const r = this.props.play; return e.play !== r && (e.play ? this.timer = setInterval(() => t.updateTime(), 1e3) : clearInterval(this.timer)), !0; }, i.componentWillUnmount = function () { clearInterval(this.timer); }, i.render = function () { const e = this.props; const n = e.wrapperStyle; const i = e.flipNumberProps; const a = this.state; const s = a.hours; const u = a.minutes; const p = a.seconds; return t.createElement(r.View, { style: [l.wrapper, n] }, !!s && t.createElement(v, o({ number: s, unit: 'hours' }, i)), t.createElement(S, null), !!u && t.createElement(v, o({ number: u, unit: 'minutes' }, i)), t.createElement(S, null), !!p && t.createElement(v, o({ number: p, unit: 'seconds' }, i))); }, n; }(t.Component)); w.defaultProps = { play: !0, wrapperStyle: {} }, w.propTypes = {
    time: n.oneOfType([n.string, n.number]).isRequired,
    play: n.bool,
    wrapperStyle: n.object,
    flipNumberProps: n.shape({
      size: n.number, perspective: n.number, numberWrapperStyle: n.object, cardStyle: n.object, flipCardStyle: n.object, numberStyle: n.object,
    }),
  }, e.Timer = w, e.FlipNumber = v, Object.defineProperty(e, '__esModule', { value: !0 });
}));
// # sourceMappingURL=react-native-flip-timer.min.js.map
